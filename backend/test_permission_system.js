/**
 * Test Script - H·ªá Th·ªëng Ph√¢n Quy·ªÅn
 * Ch·∫°y: node test_permission_system.js
 */

require('dotenv').config();
const mongoose = require('mongoose');
const Permission = require('./src/models/permission.model');
const UserPermission = require('./src/models/user_permission.model');
const User = require('./src/models/user.model');
const bcrypt = require('bcryptjs');

const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m'
};

const log = {
  success: (msg) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),
  error: (msg) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),
  info: (msg) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),
  test: (msg) => console.log(`${colors.cyan}üß™ ${msg}${colors.reset}`),
  warn: (msg) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`)
};

// K·∫øt n·ªëi MongoDB
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/pbl6');
    log.success('K·∫øt n·ªëi MongoDB th√†nh c√¥ng!');
  } catch (error) {
    log.error('K·∫øt n·ªëi MongoDB th·∫•t b·∫°i: ' + error.message);
    process.exit(1);
  }
};

// Test 1: Ki·ªÉm tra c√≥ permissions kh√¥ng
async function test1_checkPermissionsExist() {
  log.test('TEST 1: Ki·ªÉm tra permissions c√≥ t·ªìn t·∫°i kh√¥ng');
  
  const permissions = await Permission.find({});
  
  if (permissions.length === 0) {
    log.error('Kh√¥ng c√≥ permission n√†o! Ch·∫°y seed script tr∆∞·ªõc: node src/seed_permission_system.js');
    return false;
  }
  
  log.success(`T√¨m th·∫•y ${permissions.length} permissions`);
  permissions.forEach(p => {
    console.log(`   - ${p.name_per}: ${p.details.length} actions`);
  });
  
  return true;
}

// Test 2: T·∫°o user test
async function test2_createTestUsers() {
  log.test('TEST 2: T·∫°o users test');
  
  const testUsers = [
    {
      name: 'Admin Test',
      email: 'admin@test.com',
      password: await bcrypt.hash('password123', 10),
      role: 'admin'
    },
    {
      name: 'Student Test',
      email: 'student@test.com',
      password: await bcrypt.hash('password123', 10),
      role: 'student'
    },
    {
      name: 'Teacher Test',
      email: 'teacher@test.com',
      password: await bcrypt.hash('password123', 10),
      role: 'ctsv'
    }
  ];
  
  const createdUsers = [];
  
  for (const userData of testUsers) {
    let user = await User.findOne({ email: userData.email });
    
    if (!user) {
      user = await User.create(userData);
      log.success(`T·∫°o user: ${user.email} (${user.role})`);
    } else {
      log.info(`User ƒë√£ t·ªìn t·∫°i: ${user.email}`);
    }
    
    createdUsers.push(user);
  }
  
  return createdUsers;
}

// Test 3: G√°n permissions cho users
async function test3_grantPermissions(users) {
  log.test('TEST 3: G√°n permissions cho users');
  
  const [admin, student, teacher] = users;
  const permissions = await Permission.find({});
  
  // Admin c√≥ t·∫•t c·∫£ permissions
  log.info('G√°n t·∫•t c·∫£ permissions cho Admin...');
  for (const perm of permissions) {
    await UserPermission.grantPermission(admin._id, perm._id);
  }
  log.success(`Admin c√≥ ${permissions.length} permissions`);
  
  // Student ch·ªâ c√≥ m·ªôt s·ªë permissions
  log.info('G√°n permissions h·∫°n ch·∫ø cho Student...');
  const studentPerms = permissions.filter(p => 
    p.name_per === 'EVIDENCE_MANAGEMENT' || p.name_per === 'REPORT_VIEW'
  );
  for (const perm of studentPerms) {
    await UserPermission.grantPermission(student._id, perm._id);
  }
  log.success(`Student c√≥ ${studentPerms.length} permissions`);
  
  // Teacher c√≥ permissions trung b√¨nh
  log.info('G√°n permissions cho Teacher...');
  const teacherPerms = permissions.filter(p => 
    p.name_per === 'ACTIVITY_MANAGEMENT' || 
    p.name_per === 'ATTENDANCE_MANAGEMENT' ||
    p.name_per === 'REPORT_VIEW'
  );
  for (const perm of teacherPerms) {
    await UserPermission.grantPermission(teacher._id, perm._id);
  }
  log.success(`Teacher c√≥ ${teacherPerms.length} permissions`);
  
  return true;
}

// Test 4: Ki·ªÉm tra permissions c·ªßa users
async function test4_checkUserPermissions(users) {
  log.test('TEST 4: Ki·ªÉm tra permissions c·ªßa t·ª´ng user');
  
  for (const user of users) {
    console.log(`\n   üë§ ${user.name} (${user.email}):`);
    
    const userPerms = await UserPermission.getUserPermissions(user._id);
    
    if (userPerms.length === 0) {
      log.warn(`   Kh√¥ng c√≥ permission n√†o`);
      continue;
    }
    
    for (const up of userPerms) {
      // Skip if permission data not populated
      if (!up.id_per || !up.id_per.details) {
        console.log(`   ‚ö†Ô∏è  Permission data not loaded`);
        continue;
      }
      
      const enabledActions = up.id_per.details.filter(d => d.check_action).length;
      const totalActions = up.id_per.details.length;
      
      console.log(`   ‚úÖ ${up.id_per.name_per}: ${enabledActions}/${totalActions} actions enabled`);
    }
  }
  
  return true;
}

// Test 5: Test ki·ªÉm tra quy·ªÅn c·ª• th·ªÉ
async function test5_testSpecificPermissions(users) {
  log.test('TEST 5: Test ki·ªÉm tra quy·ªÅn c·ª• th·ªÉ');
  
  const [admin, student, teacher] = users;
  const activityPerm = await Permission.findOne({ name_per: 'ACTIVITY_MANAGEMENT' });
  const evidencePerm = await Permission.findOne({ name_per: 'EVIDENCE_MANAGEMENT' });
  
  if (!activityPerm || !evidencePerm) {
    log.warn('Kh√¥ng t√¨m th·∫•y permissions c·∫ßn test');
    return false;
  }
  
  // Test Admin c√≥ ACTIVITY_MANAGEMENT kh√¥ng
  const adminHasActivity = await UserPermission.hasPermission(admin._id, activityPerm._id);
  console.log(`   Admin c√≥ ACTIVITY_MANAGEMENT: ${adminHasActivity ? '‚úÖ YES' : '‚ùå NO'}`);
  
  // Test Student c√≥ ACTIVITY_MANAGEMENT kh√¥ng (should be NO)
  const studentHasActivity = await UserPermission.hasPermission(student._id, activityPerm._id);
  console.log(`   Student c√≥ ACTIVITY_MANAGEMENT: ${studentHasActivity ? '‚ùå YES (BUG!)' : '‚úÖ NO (Correct)'}`);
  
  // Test Student c√≥ EVIDENCE_MANAGEMENT kh√¥ng (should be YES)
  const studentHasEvidence = await UserPermission.hasPermission(student._id, evidencePerm._id);
  console.log(`   Student c√≥ EVIDENCE_MANAGEMENT: ${studentHasEvidence ? '‚úÖ YES' : '‚ùå NO (BUG!)'}`);
  
  return true;
}

// Test 6: Test action-level permissions
async function test6_testActionLevelPermissions(users) {
  log.test('TEST 6: Test action-level permissions');
  
  const activityPerm = await Permission.findOne({ name_per: 'ACTIVITY_MANAGEMENT' });
  
  if (!activityPerm) {
    log.warn('Kh√¥ng t√¨m th·∫•y ACTIVITY_MANAGEMENT permission');
    return false;
  }
  
  console.log(`\n   Permission: ${activityPerm.name_per}`);
  console.log('   Actions:');
  
  activityPerm.details.forEach(detail => {
    const status = detail.check_action ? '‚úÖ ALLOWED' : '‚ùå DENIED';
    console.log(`     - ${detail.action_code}: ${status}`);
  });
  
  // Test specific action
  const canCreate = activityPerm.isActionAllowed('CREATE');
  const canDelete = activityPerm.isActionAllowed('DELETE');
  
  console.log(`\n   Test isActionAllowed():`);
  console.log(`     - CREATE: ${canCreate ? '‚úÖ Allowed' : '‚ùå Denied'}`);
  console.log(`     - DELETE: ${canDelete ? '‚ùå Allowed (BUG!)' : '‚úÖ Denied (Correct)'}`);
  
  return true;
}

// Test 7: Test revoke permission
async function test7_testRevokePermission(users) {
  log.test('TEST 7: Test thu h·ªìi permission');
  
  const [admin] = users;
  const reportPerm = await Permission.findOne({ name_per: 'REPORT_VIEW' });
  
  if (!reportPerm) {
    log.warn('Kh√¥ng t√¨m th·∫•y REPORT_VIEW permission');
    return false;
  }
  
  // Check before revoke
  const beforeRevoke = await UserPermission.hasPermission(admin._id, reportPerm._id);
  console.log(`   Admin c√≥ REPORT_VIEW tr∆∞·ªõc khi revoke: ${beforeRevoke ? '‚úÖ YES' : '‚ùå NO'}`);
  
  // Revoke
  await UserPermission.revokePermission(admin._id, reportPerm._id);
  log.info('   ƒê√£ revoke REPORT_VIEW t·ª´ Admin');
  
  // Check after revoke
  const afterRevoke = await UserPermission.hasPermission(admin._id, reportPerm._id);
  console.log(`   Admin c√≥ REPORT_VIEW sau khi revoke: ${afterRevoke ? '‚ùå YES (BUG!)' : '‚úÖ NO (Correct)'}`);
  
  // Grant l·∫°i
  await UserPermission.grantPermission(admin._id, reportPerm._id);
  log.info('   ƒê√£ grant l·∫°i REPORT_VIEW cho Admin');
  
  return true;
}

// Test 8: Test time-based permissions
async function test8_testTimeBasedPermissions(users) {
  log.test('TEST 8: Test time-based permissions');
  
  const [, student] = users;
  const activityPerm = await Permission.findOne({ name_per: 'ACTIVITY_MANAGEMENT' });
  
  // Grant v·ªõi expires_at trong t∆∞∆°ng lai
  const futureDate = new Date();
  futureDate.setDate(futureDate.getDate() + 7); // 7 ng√†y sau
  
  await UserPermission.grantPermission(
    student._id, 
    activityPerm._id, 
    null, 
    futureDate
  );
  
  log.info(`   Granted ACTIVITY_MANAGEMENT cho Student ƒë·∫øn ${futureDate.toLocaleDateString()}`);
  
  // Check c√≥ permission kh√¥ng
  const hasPermNow = await UserPermission.hasPermission(student._id, activityPerm._id);
  console.log(`   Student c√≥ permission b√¢y gi·ªù: ${hasPermNow ? '‚úÖ YES' : '‚ùå NO'}`);
  
  // Simulate expired date
  const pastDate = new Date();
  pastDate.setDate(pastDate.getDate() - 1); // 1 ng√†y tr∆∞·ªõc
  
  await UserPermission.findOneAndUpdate(
    { id_user: student._id, id_per: activityPerm._id },
    { expires_at: pastDate }
  );
  
  log.info('   Changed expires_at to past date');
  
  const hasPermAfterExpire = await UserPermission.hasPermission(student._id, activityPerm._id);
  console.log(`   Student c√≥ permission sau khi expire: ${hasPermAfterExpire ? '‚ùå YES (BUG!)' : '‚úÖ NO (Correct)'}`);
  
  // Cleanup
  await UserPermission.findOneAndDelete({ id_user: student._id, id_per: activityPerm._id });
  
  return true;
}

// Test 9: Generate test report
async function test9_generateReport(users) {
  log.test('TEST 9: T·∫°o b√°o c√°o test');
  
  console.log('\n' + '='.repeat(60));
  console.log('üìä B√ÅO C√ÅO TEST H·ªÜ TH·ªêNG PH√ÇN QUY·ªÄN');
  console.log('='.repeat(60));
  
  // T·ªïng s·ªë permissions
  const totalPermissions = await Permission.countDocuments();
  console.log(`\nüìã T·ªïng s·ªë Permissions: ${totalPermissions}`);
  
  // T·ªïng s·ªë user permissions
  const totalUserPerms = await UserPermission.countDocuments();
  console.log(`üîó T·ªïng s·ªë User-Permission mappings: ${totalUserPerms}`);
  
  // Active user permissions
  const activeUserPerms = await UserPermission.countDocuments({ licensed: true });
  console.log(`‚úÖ Active permissions: ${activeUserPerms}`);
  
  // Revoked permissions
  const revokedUserPerms = await UserPermission.countDocuments({ licensed: false });
  console.log(`‚ùå Revoked permissions: ${revokedUserPerms}`);
  
  // Permissions per user
  console.log('\nüë• Permissions per User:');
  for (const user of users) {
    const count = await UserPermission.countDocuments({ 
      id_user: user._id, 
      licensed: true 
    });
    console.log(`   - ${user.name}: ${count} permissions`);
  }
  
  // Most used permission
  const permUsage = await UserPermission.aggregate([
    { $match: { licensed: true } },
    { $group: { _id: '$id_per', count: { $sum: 1 } } },
    { $sort: { count: -1 } },
    { $limit: 1 }
  ]);
  
  if (permUsage.length > 0) {
    const mostUsedPerm = await Permission.findById(permUsage[0]._id);
    console.log(`\nüèÜ Most used permission: ${mostUsedPerm.name_per} (${permUsage[0].count} users)`);
  }
  
  console.log('\n' + '='.repeat(60));
  
  return true;
}

// Main test runner
async function runAllTests() {
  try {
    console.log('\n' + '='.repeat(60));
    console.log('üöÄ B·∫ÆT ƒê·∫¶U TEST H·ªÜ TH·ªêNG PH√ÇN QUY·ªÄN');
    console.log('='.repeat(60) + '\n');
    
    await connectDB();
    
    // Run tests
    let testResults = [];
    
    testResults.push(await test1_checkPermissionsExist());
    
    if (!testResults[0]) {
      log.error('Test 1 failed. Stopping...');
      return;
    }
    
    const users = await test2_createTestUsers();
    testResults.push(!!users);
    
    testResults.push(await test3_grantPermissions(users));
    testResults.push(await test4_checkUserPermissions(users));
    testResults.push(await test5_testSpecificPermissions(users));
    testResults.push(await test6_testActionLevelPermissions(users));
    testResults.push(await test7_testRevokePermission(users));
    testResults.push(await test8_testTimeBasedPermissions(users));
    testResults.push(await test9_generateReport(users));
    
    // Summary
    const passedTests = testResults.filter(r => r === true).length;
    const totalTests = testResults.length;
    
    console.log('\n' + '='.repeat(60));
    console.log('üìä K·∫æT QU·∫¢ TEST');
    console.log('='.repeat(60));
    console.log(`‚úÖ Passed: ${passedTests}/${totalTests}`);
    console.log(`‚ùå Failed: ${totalTests - passedTests}/${totalTests}`);
    
    if (passedTests === totalTests) {
      log.success('\nüéâ T·∫§T C·∫¢ TESTS ƒê·ªÄU PASS! H·ªÜ TH·ªêNG HO·∫†T ƒê·ªòNG HO√ÄN H·∫¢O!');
    } else {
      log.error('\n‚ùå C√ì TESTS B·ªä FAIL. KI·ªÇM TRA L·∫†I!');
    }
    
    console.log('\nüí° Th√¥ng tin login cho test users:');
    console.log('   Email: admin@test.com    | Password: password123');
    console.log('   Email: student@test.com  | Password: password123');
    console.log('   Email: teacher@test.com  | Password: password123');
    console.log('\n');
    
  } catch (error) {
    log.error('Error running tests: ' + error.message);
    console.error(error);
  } finally {
    await mongoose.connection.close();
    log.info('ƒê√£ ƒë√≥ng k·∫øt n·ªëi MongoDB');
  }
}

// Run if called directly
if (require.main === module) {
  runAllTests();
}

module.exports = { runAllTests };

